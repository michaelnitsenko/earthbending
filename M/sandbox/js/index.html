<!DOCTYPE>
<html>

<head>
	<title>Earthbending</title>
	<meta charset="UTF-8">
	<script type="text/javascript" src="three.r108.js"></script>
	<script type="text/javascript" src="OrbitControls.js"></script>
	<script type="text/javascript" src="THREEx.KeyboardState.js"></script>
	<script type="text/javascript">

		var clock = new THREE.Clock();
		var keyboard = new THREEx.KeyboardState();
		var controls;

		var renderer, scene, camera;
		var terrain, terrainObj;
		var obj;

		var fov = 80;
		var width = 800;
		var height = 500;

		var cubeVertexShader, cubeFragmentShader;

		function millis() {

			return (new Date()).getTime();
		}

		function toRad(degree) {

			return Math.PI * 2 * degree / 360;
		}

		function onLoad() {
			var canvasContainer = document.getElementById('myCanvasContainer');

			cubeVertexShader = document.getElementById('vertexShader').textContent;
			cubeFragmentShader = document.getElementById('fragmentShader').textContent;

			renderer = new THREE.WebGLRenderer();
			renderer.setSize(width, height);
			canvasContainer.appendChild(renderer.domElement);

			scene = new THREE.Scene();

			camera = new THREE.PerspectiveCamera(fov, width / height, 1, 1000);
			camera.position.y = 100;
			camera.up = new THREE.Vector3(0, 0, -1);
			camera.lookAt(new THREE.Vector3(0, 0, 0));
			scene.add(camera);

			controls = new THREE.OrbitControls(camera);

			addTerrain();

			draw();
		}

		var splitted = false;
		function parseControls(dt) {
			if (keyboard.pressed("left")) {
				if (!splitted) {
					splitted = true
					obj = splitTerrain()
					console.log("split")
				}
			}

			if (splitted) {
				if (keyboard.pressed("up")) {
					console.log("up")
					obj.position.y += 1;
				}
				if (keyboard.pressed("down")) {
					console.log("down")
					obj.position.y -= 1;
				}
			}
		}

		function draw() {
			var dt = clock.getDelta();
			var time = clock.getElapsedTime();

			requestAnimationFrame(draw);
			parseControls(dt);
			controls.update();

			renderer.setViewport(0, 0, width, height);
			renderer.setScissorTest(false);

			renderer.render(scene, camera);
		}

		function splitTerrain() {
			var vertices = [...terrain.geometry.vertices];
			var modified_vertices = [...terrain.geometry.vertices];
			for (var vi in vertices) {
				var v = vertices[vi];
				var v4 = new THREE.Vector4(v.x, v.y, v.z, 1);
				v4.applyMatrix4(terrain.matrixWorld); // going to world coordinate
				var v3 = new THREE.Vector4(v4.x, v4.y, v4.z);
				vertices[vi] = v3;
			}


			var obj = createCube(0x222222);
			var objVertices = obj.geometry.vertices;

			obj.scale.set(20, 20, 20);
			scene.add(obj);

			var faces = [];
			for (var objVertice_index in objVertices) {
				var objV3 = objVertices[objVertice_index];
				var objV4 = new THREE.Vector4(objV3.x, objV3.y, objV3.z, 1);
				objV4.applyMatrix4(obj.matrixWorld);
				var objVertice = new THREE.Vector3(objV4.x, objV4.y, objV4.z);
				console.log(objV3)
				console.log(objV4)
				if (objVertice.y === 1) {
					// on the surface
					modified_vertices.push(objVertice);
					
					var closest_vertices = [...vertices];
					
					closest_vertices.sort(function (point1, point2) {
						var d1 = point1.distanceTo(objVertice)
						var d2 = point2.distanceTo(objVertice)
						return d1 > d2 ? 1 : (d1 < d2 ? -1 : 0) 
					});

					var v1 = closest_vertices[0];
					var v1i = vertices.indexOf(v1);
					var v2 = closest_vertices[1];
					var v2i = vertices.indexOf(v2);
					var v3 = closest_vertices[2];
					var v3i = vertices.indexOf(v3);
					var vlasti = modified_vertices.length - 1;

					// for (var vi in closest_vertices) {
					// 	var v = closest_vertices[vi];
					// 	console.log(objVertice.distanceTo(v))
					// }

					var face1 = new THREE.Face3(v1i, vlasti, v2i);
					faces.push(face1);
					var face2 = new THREE.Face3(v2i, vlasti, v1i);
					faces.push(face2);
				}
			}

			terrain.geometry.vertices = modified_vertices;
			terrain.geometry.faces = faces;

			terrain.geometry.verticesNeedUpdate = true;
			terrain.geometry.elementsNeedUpdate = true;

			return obj;
		}

		function addTerrain() {
			var terrainObj = new THREE.Object3D();
			var halfPi = Math.PI / 2;

			terrain = createTerrain();
			terrain.scale.set(50, 50, 50);
			terrain.position.set(0, -10, 0);
			terrain.rotation.set(-halfPi, 0, 0);
			terrainObj.add(terrain);

			scene.add(terrainObj);
		}

		function createTerrain() {
			var geometry = new THREE.Geometry();
			geometry.dynamic = true;

			var vertices = [
				-1.0, -1.0, 0.0, // 0
				1.0, -1.0, 0.0, // 1
				1.0, 1.0, 0.0, // 2
				-1.0, 1.0, 0.0, // 3
			];

			var faces = [
				0, 1, 2,
				0, 2, 3,
			];

			var verticesCount = vertices.length;
			for (i = 0; i < verticesCount; i += 3) {
				geometry.vertices.push(new THREE.Vector3(
					vertices[i],
					vertices[i + 1],
					vertices[i + 2],
				))
			}

			var facesCount = faces.length;
			for (i = 0; i < facesCount; i += 3) {
				geometry.faces.push(new THREE.Face3(
					faces[i],
					faces[i + 1],
					faces[i + 2],
				))
			}

			var material = new THREE.MeshBasicMaterial({
				color: 0x222222
			});
			var terrainMesh = new THREE.Mesh(geometry, material);

			return terrainMesh;
		}
		function createCube(colorCode) {
			var geometry = new THREE.BoxGeometry(2, 2, 2);
			var material = new THREE.MeshBasicMaterial({
				color: 0x666666
			});
			var cube = new THREE.Mesh(geometry, material);
			cube.position.y = -30.0;

			return cube;
		}

		function createBufferCube(colorCode) {
			var geometry = new THREE.BoxBufferGeometry(2, 2, 2);
			var darkColor = new THREE.Color(colorCode).multiplyScalar(0.5);
			var lightColor = new THREE.Color(colorCode);

			var elementsPerVertexCount = 3
			var verticesPerFace = 4
			var facesCount = 6
			var verticesCount = verticesPerFace * facesCount
			var array = new Float32Array(elementsPerVertexCount * verticesCount)

			for (var i = 0; i < facesCount; i++) {
				for (var j = 0; j < verticesPerFace; j++) {
					var currentVertice = i * (verticesPerFace) + j
					var k = currentVertice * elementsPerVertexCount

					var x = geometry.attributes.position.array[k]
					var color = x > 0 ? darkColor : lightColor

					array[k] = color.r
					array[k + 1] = color.g
					array[k + 2] = color.b
				}
			}

			geometry.addAttribute("vertexColor", new THREE.BufferAttribute(array, elementsPerVertexCount))

			var material = new THREE.ShaderMaterial({
				vertexShader: cubeVertexShader,
				fragmentShader: cubeFragmentShader
			});
			var cube = new THREE.Mesh(geometry, material);
			cube.position.y = -30.0;

			return cube;
		}

	</script>
	<script id="vertexShader" type="x-shader/x-vertex">
			attribute vec3 vertexColor;
			varying vec3 interpolatedColor;
			
			void main() {
				interpolatedColor = vertexColor;
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			}
		</script>
	<script id="fragmentShader" type="x-shader/x-fragment">
			varying vec3 interpolatedColor;
			
			void main() {
				gl_FragColor = vec4(interpolatedColor, 1.0);
			}
		</script>
</head>

<body onload="onLoad()">
	<div id="myCanvasContainer"></div>
</body>

</html>