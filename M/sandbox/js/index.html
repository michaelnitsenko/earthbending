<!DOCTYPE>
<html>

<head>
	<title>Earthbending</title>
	<meta charset="UTF-8">
	<script type="text/javascript" src="three.r108.js"></script>
	<script type="text/javascript" src="OrbitControls.js"></script>
	<script type="text/javascript" src="THREEx.KeyboardState.js"></script>
	<script type="text/javascript">

		var clock = new THREE.Clock();
		var keyboard = new THREEx.KeyboardState();
		var controls;

		var renderer, scene, camera;
		var map;
		var mapWidth = 10;
		var mapHeight = 10;
		var maxTerrainHeight = 100;

		var terrain;
		var character;
		var actionRadius = 2;

		var fov = 80;
		var width = 800;
		var height = 500;

		var cubeVertexShader, cubeFragmentShader;

		function millis() {

			return (new Date()).getTime();
		}

		function toRad(degree) {

			return Math.PI * 2 * degree / 360;
		}

		function onLoad() {
			var canvasContainer = document.getElementById('myCanvasContainer');

			renderer = new THREE.WebGLRenderer();
			renderer.setSize(width, height);
			canvasContainer.appendChild(renderer.domElement);

			genMap();

			scene = new THREE.Scene();
			addCamera();
			addLight();
			addTerrain();
			addCharacter();

			draw();
		}

		function genMap() {
			map = [];
			var middleTerrainHeight = maxTerrainHeight / 2;
			for (var i = 0; i < mapWidth; i++) {
				var row = [];
				for (var j = 0; j < mapHeight; j++) {
					row.push(middleTerrainHeight);
				}
				map.push(row)
			}
		}

		function xyDistance(point1, point2) {
			return Math.pow(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2), 0.5)
		}

		function calculateActionPoint(radius) {
			var actionPoint = new THREE.Vector3();
			character.getWorldPosition(actionPoint);
			var actionDirection = new THREE.Vector3();
			character.getWorldDirection(actionDirection);
			actionDirection.addScaledVector(actionDirection, radius + 1);
			actionPoint.add(actionDirection);

			return actionPoint
		}

		function getTerrainVerticesInXYRadius(point, radius) {
			var vertices = terrain.geometry.vertices;
			var terrainPosition = new THREE.Vector3();
			terrain.getWorldPosition(terrainPosition);

			var selectedVertices = [];

			for (var vertexIndex in vertices) {
				var meshVertex = vertices[vertexIndex];
				var vertex = new THREE.Vector3().copy(meshVertex);
				vertex.add(terrainPosition);
				if (xyDistance(vertex, point) < radius) {
					selectedVertices.push(meshVertex);
				}
			}

			return selectedVertices;
		}

		function parseControls(dt) {
			if (keyboard.pressed("left")) {
				chipTerrain(calculateActionPoint(actionRadius));
			}
			if (keyboard.pressed("up")) {
				raiseTerrain(calculateActionPoint(actionRadius));
			}
			if (keyboard.pressed("down")) {
				lowerTerrain(calculateActionPoint(actionRadius));
			}
			if (keyboard.pressed("w")) {
				character.translateZ(0.1);
			}
			if (keyboard.pressed("s")) {
				character.translateZ(-0.1);
			}
			if (keyboard.pressed("a")) {
				character.rotateX(-0.1);
			}
			if (keyboard.pressed("d")) {
				character.rotateX(0.1);
			}
		}

		function draw() {
			var dt = clock.getDelta();
			var time = clock.getElapsedTime();

			requestAnimationFrame(draw);
			parseControls(dt);
			controls.update();

			renderer.setViewport(0, 0, width, height);
			renderer.setScissorTest(false);

			renderer.render(scene, camera);
		}

		function addCamera() {
			camera = new THREE.PerspectiveCamera(fov, width / height, 1, 1000);
			camera.position.z = 10;
			camera.up = new THREE.Vector3(0, 1, 0);
			camera.lookAt(new THREE.Vector3(0, 0, 0));
			scene.add(camera);

			controls = new THREE.OrbitControls(camera);
		}

		function updateCameraPosition() {
			var backward = new THREE.Vector3();
			scene.getWorldDirection(backward);
			console.log(backward)
			backward.applyAxisAngle(new THREE.Vector3(0, 1, 0), character.rotation.y);

			var center = new THREE.Vector3().copy(character.position).add(new THREE.Vector3(0, 0, 0));
			var cameraPositionOffset = new THREE.Vector3().copy(backward).multiply(new THREE.Vector3(3, 3, 3)).add(new THREE.Vector3(0, 0, 0));
			var cameraPosition = new THREE.Vector3().copy(character.position).add(cameraPositionOffset);
			camera.position.set(cameraPosition.x, cameraPosition.y, cameraPosition.z);
			camera.lookAt(center);
		}

		function addLight() {
			var light = new THREE.DirectionalLight( 0xffffff, 0.5 );
			light.position.set(0, 0, 1);
			scene.add(light);
		}

		function addCharacter() {
			character = createCharacter();
			scene.add( character );
		}

		function createCharacter() {
			var geometry = new THREE.BoxBufferGeometry( 1, 1, 1 );
			var material = new THREE.MeshNormalMaterial();
			var cube = new THREE.Mesh( geometry, material );
			cube.lookAt(1, 0, 0)
			
			return cube;
		}

		function addTerrain() {
			var terrainObj = new THREE.Object3D();
			var halfPi = Math.PI / 2;

			terrain = createTerrain();
			
			var heightCenter = mapHeight / 2;
			var widthCenter = mapWidth / 2;
			terrainObj.position.set(-widthCenter, -heightCenter, 0);
			terrainObj.add(terrain);

			scene.add(terrainObj);
		}

		function createTerrain() {
			var geometry = new THREE.Geometry();
			geometry.dynamic = true;
			var vertices = [];
			var faces = [];

			for (var rowIndex = 0; rowIndex < mapHeight; rowIndex++) {
				var row = map[rowIndex];
				for (var cellIndex = 0; cellIndex < mapWidth; cellIndex++) {
					var height = row[cellIndex];
					vertices.push(cellIndex);
					vertices.push(rowIndex);
					vertices.push(0);

					if (rowIndex < mapHeight - 1 && cellIndex < mapWidth - 1) {
						var index = rowIndex * mapWidth + cellIndex;
						var index_upper = index + mapWidth;

						faces.push(index);
						faces.push(index + 1);
						faces.push(index_upper);

						faces.push(index + 1);
						faces.push(index_upper + 1);
						faces.push(index_upper - 1 + 1);
					}
				}
			}

			var verticesCount = mapWidth * mapHeight * 3;
			for (i = 0; i < verticesCount; i += 3) {
				geometry.vertices.push(new THREE.Vector3(
					vertices[i],
					vertices[i + 1],
					vertices[i + 2],
				));
			}

			var facesCount = faces.length;
			for (i = 0; i < facesCount; i += 3) {
				var v1 = faces[i];
				var v2 = faces[i + 1];
				var v3 = faces[i + 2];
				var face = new THREE.Face3(
					v1,
					v2,
					v3,
				);


				var height1 = map[Math.floor(v1 / mapWidth)][v1 % mapWidth];
				var grayScale1 = height1 / maxTerrainHeight;
				//face.vertexColors[0] = new THREE.Color(grayScale1, grayScale1, grayScale1);

				var height2 = map[Math.floor(v2 / mapWidth)][v2 % mapWidth];
				var grayScale2 = height2 / maxTerrainHeight;
				//face.vertexColors[1] = new THREE.Color(grayScale2, grayScale2, grayScale2);

				var height3 = map[Math.floor(v3 / mapWidth)][v3 % mapWidth];
				var grayScale3 = height3 / maxTerrainHeight;
				//face.vertexColors[2] = new THREE.Color(grayScale3, grayScale3, grayScale3);

				geometry.faces.push(face);
			}

			var material = new THREE.MeshDepthMaterial({ vertexColors: THREE.VertexColors });
			var terrainMesh = new THREE.Mesh(geometry, material);

			return terrainMesh;
		}

		function chipTerrain(point) {
			
		}

		function lowerTerrain(point) {
			var selectedVertices = getTerrainVerticesInXYRadius(point, actionRadius);
			
			for (var vertexIndex in selectedVertices) {
				var vertice = selectedVertices[vertexIndex];
				vertice.z -= 0.1;
				terrain.geometry.verticesNeedUpdate = true;
			}
		}

		function raiseTerrain(point) {
			var selectedVertices = getTerrainVerticesInXYRadius(point, actionRadius);
			
			for (var vertexIndex in selectedVertices) {
				var vertice = selectedVertices[vertexIndex];
				vertice.z += 0.1;
				terrain.geometry.verticesNeedUpdate = true;
			}
		}

	</script>
</head>

<body onload="onLoad()">
	<div id="myCanvasContainer"></div>
</body>

</html>