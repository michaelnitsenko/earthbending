<!DOCTYPE>
<html>

<head>
	<title>Earthbending</title>
	<meta charset="UTF-8">
	<script type="text/javascript" src="three.r108.js"></script>
	<script type="text/javascript" src="OrbitControls.js"></script>
	<script type="text/javascript" src="THREEx.KeyboardState.js"></script>
	<script type="text/javascript">

		var clock = new THREE.Clock();
		var keyboard = new THREEx.KeyboardState();
		var controls;

		var renderer, scene, camera;
		var map;
		var mapWidth = 10;
		var mapHeight = 10;
		var maxTerrainHeight = 100;

		var terrain, terrainObj;
		var obj;

		var fov = 80;
		var width = 800;
		var height = 500;

		var cubeVertexShader, cubeFragmentShader;

		function millis() {

			return (new Date()).getTime();
		}

		function toRad(degree) {

			return Math.PI * 2 * degree / 360;
		}

		function onLoad() {
			var canvasContainer = document.getElementById('myCanvasContainer');

			renderer = new THREE.WebGLRenderer();
			renderer.setSize(width, height);
			canvasContainer.appendChild(renderer.domElement);

			genMap();

			scene = new THREE.Scene();
			addCamera();
			addLight();
			addTerrain();

			draw();
		}

		function genMap() {
			map = [];
			var middleTerrainHeight = maxTerrainHeight / 2;
			for (var i = 0; i < mapWidth; i++) {
				var row = [];
				for (var j = 0; j < mapHeight; j++) {
					row.push(middleTerrainHeight);
				}
				map.push(row)
			}
		}

		function parseControls(dt) {
			if (keyboard.pressed("left")) {

			}
			if (keyboard.pressed("up")) {
				
			}
			if (keyboard.pressed("down")) {
				
			}
		}

		function draw() {
			var dt = clock.getDelta();
			var time = clock.getElapsedTime();

			requestAnimationFrame(draw);
			parseControls(dt);
			controls.update();

			renderer.setViewport(0, 0, width, height);
			renderer.setScissorTest(false);

			renderer.render(scene, camera);
		}

		function addCamera() {
			camera = new THREE.PerspectiveCamera(fov, width / height, 1, 1000);
			camera.position.z = 10;
			camera.up = new THREE.Vector3(0, 1, 0);
			camera.lookAt(new THREE.Vector3(0, 0, 0));
			scene.add(camera);

			controls = new THREE.OrbitControls(camera);
		}

		function addLight() {
			var light = new THREE.PointLight( 0xff0000, 1, 100 );
			light.position.set( 50, 50, 50 );
			scene.add( light );
		}

		function addTerrain() {
			var terrainObj = new THREE.Object3D();
			var halfPi = Math.PI / 2;

			terrain = createTerrain();
			terrainObj.add(terrain);

			scene.add(terrainObj);
		}

		function createTerrain() {
			var geometry = new THREE.Geometry();
			geometry.dynamic = true;
			var vertices = [];
			var faces = [];

			var rowsCount = map.length;
			var cellsCount = map[0].length;
			var heightCenter = rowsCount / 2;
			var widthCenter = cellsCount / 2;
			for (var rowIndex = 0; rowIndex < rowsCount; rowIndex++) {
				var row = map[rowIndex];
				for (var cellIndex = 0; cellIndex < cellsCount; cellIndex++) {
					var height = row[cellIndex];
					vertices.push(cellIndex - widthCenter);
					vertices.push(rowIndex - heightCenter);
					vertices.push(height);

					if (rowIndex < rowsCount - 1 && cellIndex < cellsCount - 1) {
						var index = rowIndex * cellsCount + cellIndex;
						var index_upper = (rowIndex + 1) * cellsCount + cellIndex;

						faces.push(index);
						faces.push(index + 1);
						faces.push(index_upper);

						faces.push(index + 1);
						faces.push(index_upper + 1);
						faces.push(index_upper - 1 + 1);
					}
				}
			}

			var verticesCount = rowsCount * cellsCount * 3;
			for (i = 0; i < verticesCount; i += 3) {
				geometry.vertices.push(new THREE.Vector3(
					vertices[i],
					vertices[i + 1],
					vertices[i + 2],
				));
			}

			var facesCount = faces.length;
			for (i = 0; i < facesCount; i += 3) {
				var face = new THREE.Face3(
					faces[i],
					faces[i + 1],
					faces[i + 2],
				);

				var height1 = vertices[i * 3  + 2];
				var grayScale1 = height1 / maxTerrainHeight;
				face.vertexColors[0] = new THREE.Color(grayScale1, grayScale1, grayScale1);
				var height2 = vertices[(i + 1) * 3  + 2];
				var grayScale2 = height2 / maxTerrainHeight;
				face.vertexColors[1] = new THREE.Color(grayScale2, grayScale2, grayScale2);
				var height3 = vertices[(i + 2) * 3  + 2];
				var grayScale3 = height3 / maxTerrainHeight;
				face.vertexColors[2] = new THREE.Color(grayScale3, grayScale3, grayScale3);
				geometry.faces.push(face);
			}

			var material = new THREE.MeshBasicMaterial({ vertexColors: THREE.VertexColors });
			var terrainMesh = new THREE.Mesh(geometry, material);

			return terrainMesh;
		}

		function chipTerrain(point) {

		}

		function lowerTerrain(point) {

		}

		function raiseTerrain(point) {

		}

	</script>
</head>

<body onload="onLoad()">
	<div id="myCanvasContainer"></div>
</body>

</html>